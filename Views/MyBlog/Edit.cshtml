@model Blog7.Models.MainVM

<div class="myBlogSpaceMain container mt-5 mb-5 pb-2 pt-2 rounded-3 border" style="background-color: rgb(240, 240, 240)">

    <h1>Edit Post</h1>

@*    <div id="partialViewContainer">
        <partial name="_Post" />
    </div>*@

    <form method="POST" class="mb-5 sendPostFormEdit" asp-action="SaveEditedPost" enctype="multipart/form-data">

        <input type="hidden" name="id" value="@Model.Post.Id"/>

        <div asp-validation-summary="ModelOnly" class="text-danger"> </div>

        <!-- title input -->

        <div class="form-outline mb-2">
            <label class="form-label labelTitle" asp-for="TextEditor.Title"></label>
            <div>
                <input asp-for="TextEditor.Title" name="Title" class="form-control inputTitle" value="@Model.Post.Title"/>
                <span asp-validation-for="TextEditor.Title" class="text-danger"></span>
            </div>
        </div>

        <!-- category select -->

        <div class="form-outline mb-3">
            <label class="form-label labelCategory" asp-for="TextEditor.Category"></label>
            <div class="selectCategory">
                <select class="form-select SELECTmulti" name="Category" multiple>

                    @if (Model.PostCategory != null && Model.Post.Category != null)
                    {
                        var categoryIds = Model.Post.Category.Split(',').Select(x => x.Trim());

                        @foreach (var item in Model.PostCategory)
                        {
                            if (categoryIds.Contains(item.Id.ToString()))
                            {
                                <option value="@item.Id" selected>@item.CategoryName</option>
                            }
                            else
                            {
                                <option value="@item.Id">@item.CategoryName</option>
                            }
                            
                        }
                    }

                </select>

                <span asp-validation-for="TextEditor.Category" class="text-danger"></span>
            </div>
        </div>

        <!-- body input -->

        <div class="form-outline mb-4">
            <label class="form-label labelEditor" asp-for="TextEditor.RichContent">Your Post</label>
            <div class="textareaEditor">
                <textarea id="richTextEditorEdit" name="richContent" asp-for="TextEditor.RichContent" class="form-control"></textarea>
                <span asp-validation-for="TextEditor.RichContent" class="text-danger"></span>
            </div>
        </div>


        <div>
            <button type="Submit" class="btn btn-success bg-gradient">Edit Post</button>
        </div>

    </form>

</div>

@section Scripts{

    <script>

        let contentData = `@Html.Raw(Model.Post.Content)`;

        var editorInEditView = new FroalaEditor('#richTextEditorEdit', {}, function () {

            // Call the method inside the initialized event.


            editorInEditView.html.insert(contentData, true);

        });


        $(document).ready(function () {
            $('.SELECTmulti').select2({
                //placeholder: "Select category..",
                initSelection: function (element, callback) {
                }
            });
        });

        //Error on blank fields
        let labelTitle = document.querySelector('.labelTitle');
        let inputTitle = document.querySelector('.inputTitle');

        inputTitle.addEventListener('mouseup', () => {
            labelTitle.innerHTML = "Title";
            labelTitle.style.color = "unset";
        });

        let labelCategory = document.querySelector('.labelCategory');
        let selectCategory = document.querySelector('.selectCategory');

        selectCategory.addEventListener('mouseup', () => {
            labelCategory.innerHTML = "Category";
            labelCategory.style.color = "unset";
        });

        let labelEditor = document.querySelector('.labelEditor');
        let textareaEditor = document.querySelector('.textareaEditor');

        textareaEditor.addEventListener('mouseup', () => {
            labelEditor.innerHTML = "Your Post";
            labelEditor.style.color = "unset";
        });

        //Form sendPostFormEdit
        var form = document.querySelector('.sendPostFormEdit');
        form.onsubmit = async function (e) {

            console.log("Run")

            e.preventDefault();

            const postTitle = document.querySelector('input[name=Title]').value;
            const category = $('.SELECTmulti').select2("val");
            const richTextContent = document.querySelector('textarea[name=richContent]').value;
            const id = document.querySelector('input[name=id]').value;

            //Errors on empty input
            if (postTitle == "") {

                labelTitle.innerHTML = "Please enter a title for your post.";
                labelTitle.style.color = "red";
                labelTitle.scrollIntoView({ behavior: "smooth", block: "end", inline: "nearest" });

                return false;
            }

            if (category == "") {
                labelCategory.innerHTML = "Please choose a category for your post.";
                labelCategory.style.color = "red";
                labelCategory.scrollIntoView({ behavior: "smooth", block: "end", inline: "nearest" });

                return false;
            }

            if (richTextContent == "") {
                labelEditor.innerHTML = "Please enter a content of your post.";
                labelEditor.style.color = "red";
                labelEditor.scrollIntoView({ behavior: "smooth", block: "end", inline: "nearest" });

                return false;
            }

            //This code defines an asynchronous function convertToBase64 that takes a URL as a parameter.It uses the Fetch API to fetch the resource at the given URL, retrieves the response as a blob, and then converts the blob to a base64 - encoded string using a FileReader.The function returns a promise that resolves with the base64 string.
            const convertToBase64 = async (url) => {
                const response = await fetch(url);
                const blob = await response.blob();
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                });
            };


            //These lines define an empty array promises and use the replace() method with a regular expression to iterate over the img tags in the richTextContent string. For each img tag, it extracts the value of the src attribute using a regex match. If the src value doesn't start with 'http' or 'https', indicating it's a local file, it calls the convertToBase64 function with the src value and adds the resulting promise to the promises array. The replace() method returns the updated content with the original img tags unchanged.
            const promises = [];
            const updatedContent = richTextContent.replace(/<img([^>]+)>/g, (match, p1) => {
                const srcMatch = p1.match(/src\s*=\s*(['"])(.*?)\1/);
                if (srcMatch) {
                    const src = srcMatch[2];
                    if (!src.startsWith('http') && !src.startsWith('https')) {
                        const base64Promise = convertToBase64(src);
                        promises.push(base64Promise);
                        return match;
                    }
                }
                return match;
            });

            //These lines use Promise.all() to await all the promises in the promises array. This ensures that all the base64 conversions are completed before further processing. The resulting array of base64 strings is stored in the base64Array variable. The code then uses the replace() method again to iterate over the img tags in the updatedContent string. It checks if the src value indicates a local file, and if so, replaces it with the corresponding base64 string from the base64Array. This updates the src attribute of the img tags with the base64-encoded images.
            const base64Array = await Promise.all(promises);
            let base64Index = 0;
            const updatedContentWithBase64 = updatedContent.replace(/<img([^>]+)>/g, (match, p1) => {
                const srcMatch = p1.match(/src\s*=\s*(['"])(.*?)\1/);
                if (srcMatch) {
                    const src = srcMatch[2];
                    if (!src.startsWith('http') && !src.startsWith('https')) {
                        const base64 = base64Array[base64Index];
                        base64Index++;
                        return match.replace(src, base64);
                    }
                }
                return match;
            });

            var form = $(this);
            var url = form.attr('action');

            const formData = new FormData();
            formData.append('RichContent', updatedContentWithBase64);
            formData.append('Title', postTitle);
            formData.append('Category', category);
            formData.append('id', id)


            $.ajax({
                url: url,
                type: 'POST',
                data: formData,
                processData: false,
                contentType: false,
                success: function (data) {

                window.location.href = '@Url.Action("Index", "MyBlog")';
                },
                error: function (xhr, status, error) {
                    var errorMessage = xhr.responseText || 'An error occurred.';
                    alert('Error: ' + errorMessage);
                    console.log(errorMessage);
                }
            });

            return false;
        };

    </script>

}